import React, { useState, useRef, useCallback } from ‘react’;
import { Plus, X, Edit3, Camera } from ‘lucide-react’;

const MindNotesUniverse = () => {
const [notes, setNotes] = useState([]);
const [isCreating, setIsCreating] = useState(false);
const [createPosition, setCreatePosition] = useState({ x: 0, y: 0 });
const [selectedNote, setSelectedNote] = useState(null);
const [editingNote, setEditingNote] = useState(null);
const [zoom, setZoom] = useState(1);
const [pan, setPan] = useState({ x: 0, y: 0 });
const [isDragging, setIsDragging] = useState(false);
const [dragStart, setDragStart] = useState({ x: 0, y: 0 });
const [isTouch, setIsTouch] = useState(false);
const canvasRef = useRef(null);
const fileInputRef = useRef(null);

// Generate random planet colors when no image is provided
const planetColors = [
‘linear-gradient(135deg, #667eea 0%, #764ba2 100%)’,
‘linear-gradient(135deg, #f093fb 0%, #f5576c 100%)’,
‘linear-gradient(135deg, #4facfe 0%, #00f2fe 100%)’,
‘linear-gradient(135deg, #43e97b 0%, #38f9d7 100%)’,
‘linear-gradient(135deg, #fa709a 0%, #fee140 100%)’,
‘linear-gradient(135deg, #a8edea 0%, #fed6e3 100%)’,
‘linear-gradient(135deg, #ff9a9e 0%, #fecfef 100%)’,
‘linear-gradient(135deg, #ffecd2 0%, #fcb69f 100%)’,
];

const handleCanvasClick = useCallback((e) => {
if (isCreating || selectedNote || editingNote || isDragging) return;

```
const rect = canvasRef.current.getBoundingClientRect();
const x = (e.clientX - rect.left - pan.x) / zoom;
const y = (e.clientY - rect.top - pan.y) / zoom;

setCreatePosition({ x, y });
setIsCreating(true);
```

}, [isCreating, selectedNote, editingNote, isDragging, pan, zoom]);

// Mouse event handlers for panning
const handleMouseDown = useCallback((e) => {
if (isCreating || selectedNote || editingNote) return;
setIsDragging(true);
setDragStart({ x: e.clientX - pan.x, y: e.clientY - pan.y });
}, [pan, isCreating, selectedNote, editingNote]);

const handleMouseMove = useCallback((e) => {
if (!isDragging) return;
setPan({
x: e.clientX - dragStart.x,
y: e.clientY - dragStart.y
});
}, [isDragging, dragStart]);

const handleMouseUp = useCallback(() => {
setIsDragging(false);
}, []);

// Touch event handlers for panning and pinch-to-zoom
const handleTouchStart = useCallback((e) => {
if (isCreating || selectedNote || editingNote) return;

```
setIsTouch(true);

if (e.touches.length === 1) {
  setIsDragging(true);
  setDragStart({ 
    x: e.touches[0].clientX - pan.x, 
    y: e.touches[0].clientY - pan.y 
  });
} else if (e.touches.length === 2) {
  const touch1 = e.touches[0];
  const touch2 = e.touches[1];
  const distance = Math.sqrt(
    Math.pow(touch2.clientX - touch1.clientX, 2) + 
    Math.pow(touch2.clientY - touch1.clientY, 2)
  );
  setDragStart({ ...dragStart, distance });
}
```

}, [pan, isCreating, selectedNote, editingNote, dragStart]);

const handleTouchMove = useCallback((e) => {
e.preventDefault();

```
if (e.touches.length === 1 && isDragging) {
  setPan({
    x: e.touches[0].clientX - dragStart.x,
    y: e.touches[0].clientY - dragStart.y
  });
} else if (e.touches.length === 2) {
  const touch1 = e.touches[0];
  const touch2 = e.touches[1];
  const distance = Math.sqrt(
    Math.pow(touch2.clientX - touch1.clientX, 2) + 
    Math.pow(touch2.clientY - touch1.clientY, 2)
  );
  
  if (dragStart.distance) {
    const scale = distance / dragStart.distance;
    const newZoom = Math.min(Math.max(zoom * scale, 0.3), 3);
    setZoom(newZoom);
    setDragStart({ ...dragStart, distance });
  }
}
```

}, [isDragging, dragStart, zoom]);

const handleTouchEnd = useCallback(() => {
setIsDragging(false);
setIsTouch(false);
}, []);

// Wheel event for desktop zoom
const handleWheel = useCallback((e) => {
e.preventDefault();
const delta = e.deltaY > 0 ? 0.9 : 1.1;
const newZoom = Math.min(Math.max(zoom * delta, 0.3), 3);
setZoom(newZoom);
}, [zoom]);

// Add event listeners
React.useEffect(() => {
const canvas = canvasRef.current;
if (!canvas) return;

```
canvas.addEventListener('mousedown', handleMouseDown);
canvas.addEventListener('mousemove', handleMouseMove);
canvas.addEventListener('mouseup', handleMouseUp);
canvas.addEventListener('mouseleave', handleMouseUp);
canvas.addEventListener('wheel', handleWheel, { passive: false });
canvas.addEventListener('touchstart', handleTouchStart, { passive: false });
canvas.addEventListener('touchmove', handleTouchMove, { passive: false });
canvas.addEventListener('touchend', handleTouchEnd);

return () => {
  canvas.removeEventListener('mousedown', handleMouseDown);
  canvas.removeEventListener('mousemove', handleMouseMove);
  canvas.removeEventListener('mouseup', handleMouseUp);
  canvas.removeEventListener('mouseleave', handleMouseUp);
  canvas.removeEventListener('wheel', handleWheel);
  canvas.removeEventListener('touchstart', handleTouchStart);
  canvas.removeEventListener('touchmove', handleTouchMove);
  canvas.removeEventListener('touchend', handleTouchEnd);
};
```

}, [handleMouseDown, handleMouseMove, handleMouseUp, handleWheel, handleTouchStart, handleTouchMove, handleTouchEnd]);

const createNote = (title, content, image = null) => {
const newNote = {
id: Date.now(),
title: title || ‘Untitled’,
content,
image,
x: createPosition.x,
y: createPosition.y,
color: planetColors[Math.floor(Math.random() * planetColors.length)],
size: Math.random() * 30 + 40 // Random size between 40-70px
};

```
setNotes([...notes, newNote]);
setIsCreating(false);
setCreatePosition({ x: 0, y: 0 });
```

};

const updateNote = (id, updates) => {
setNotes(notes.map(note =>
note.id === id ? { …note, …updates } : note
));
};

const deleteNote = (id) => {
setNotes(notes.filter(note => note.id !== id));
setSelectedNote(null);
setEditingNote(null);
};

const handleImageUpload = (file, noteId = null) => {
const reader = new FileReader();
reader.onload = (e) => {
if (noteId) {
updateNote(noteId, { image: e.target.result });
} else {
// For new note creation
setCreatePosition(prev => ({ …prev, image: e.target.result }));
}
};
reader.readAsDataURL(file);
};

const CreateNoteModal = () => {
const [title, setTitle] = useState(’’);
const [content, setContent] = useState(’’);
const [tempImage, setTempImage] = useState(null);

```
const handleSubmit = () => {
  if (!content.trim()) return;
  createNote(title, content, tempImage);
  setTitle('');
  setContent('');
  setTempImage(null);
};

const handleImageChange = (e) => {
  const file = e.target.files[0];
  if (file) {
    const reader = new FileReader();
    reader.onload = (e) => setTempImage(e.target.result);
    reader.readAsDataURL(file);
  }
};

return (
  <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50">
    <div className="bg-gray-900 p-6 rounded-lg max-w-md w-full mx-4 border border-gray-700">
      <h3 className="text-xl font-bold text-white mb-4">Create New Planet</h3>
      <div>
        <input
          type="text"
          placeholder="Planet title..."
          value={title}
          onChange={(e) => setTitle(e.target.value)}
          className="w-full p-2 mb-3 bg-gray-800 text-white rounded border border-gray-600 focus:border-blue-400 outline-none"
          autoFocus
        />
        <textarea
          placeholder="Your note or reminder..."
          value={content}
          onChange={(e) => setContent(e.target.value)}
          className="w-full p-2 mb-3 bg-gray-800 text-white rounded border border-gray-600 focus:border-blue-400 outline-none h-24 resize-none"
        />
        <div className="mb-4">
          <input
            type="file"
            accept="image/*"
            onChange={handleImageChange}
            className="hidden"
            id="image-upload"
          />
          <label
            htmlFor="image-upload"
            className="flex items-center gap-2 cursor-pointer text-blue-400 hover:text-blue-300"
          >
            <Camera size={20} />
            {tempImage ? 'Change Planet Image' : 'Add Planet Image'}
          </label>
          {tempImage && (
            <img
              src={tempImage}
              alt="Preview"
              className="mt-2 w-16 h-16 rounded-full object-cover border-2 border-gray-600"
            />
          )}
        </div>
        <div className="flex gap-2">
          <button
            onClick={handleSubmit}
            className="flex-1 bg-blue-600 hover:bg-blue-700 text-white py-2 px-4 rounded transition-colors"
          >
            Create Planet
          </button>
          <button
            onClick={() => {
              setIsCreating(false);
              setTitle('');
              setContent('');
              setTempImage(null);
            }}
            className="flex-1 bg-gray-700 hover:bg-gray-600 text-white py-2 px-4 rounded transition-colors"
          >
            Cancel
          </button>
        </div>
      </div>
    </div>
  </div>
);
```

};

const NoteModal = ({ note, onClose, isEditing, setIsEditing }) => {
const [editTitle, setEditTitle] = useState(note.title);
const [editContent, setEditContent] = useState(note.content);

```
const handleSave = () => {
  updateNote(note.id, { title: editTitle, content: editContent });
  setIsEditing(false);
};

const handleImageChange = (e) => {
  const file = e.target.files[0];
  if (file) {
    handleImageUpload(file, note.id);
  }
};

return (
  <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50">
    <div className="bg-gray-900 p-6 rounded-lg max-w-md w-full mx-4 border border-gray-700 max-h-[80vh] overflow-y-auto">
      <div className="flex justify-between items-center mb-4">
        <h3 className="text-xl font-bold text-white">Planet Details</h3>
        <div className="flex gap-2">
          <button
            onClick={() => setIsEditing(!isEditing)}
            className="text-blue-400 hover:text-blue-300"
          >
            <Edit3 size={20} />
          </button>
          <button
            onClick={onClose}
            className="text-gray-400 hover:text-white"
          >
            <X size={20} />
          </button>
        </div>
      </div>
      
      {note.image && (
        <img
          src={note.image}
          alt={note.title}
          className="w-full h-32 object-cover rounded mb-4"
        />
      )}
      
      {isEditing ? (
        <>
          <input
            type="text"
            value={editTitle}
            onChange={(e) => setEditTitle(e.target.value)}
            className="w-full p-2 mb-3 bg-gray-800 text-white rounded border border-gray-600 focus:border-blue-400 outline-none"
          />
          <textarea
            value={editContent}
            onChange={(e) => setEditContent(e.target.value)}
            className="w-full p-2 mb-3 bg-gray-800 text-white rounded border border-gray-600 focus:border-blue-400 outline-none h-32 resize-none"
          />
          <div className="mb-4">
            <input
              type="file"
              accept="image/*"
              onChange={handleImageChange}
              className="hidden"
              id="edit-image-upload"
            />
            <label
              htmlFor="edit-image-upload"
              className="flex items-center gap-2 cursor-pointer text-blue-400 hover:text-blue-300"
            >
              <Camera size={20} />
              {note.image ? 'Change Image' : 'Add Image'}
            </label>
          </div>
          <div className="flex gap-2">
            <button
              onClick={handleSave}
              className="flex-1 bg-green-600 hover:bg-green-700 text-white py-2 px-4 rounded transition-colors"
            >
              Save
            </button>
            <button
              onClick={() => setIsEditing(false)}
              className="flex-1 bg-gray-700 hover:bg-gray-600 text-white py-2 px-4 rounded transition-colors"
            >
              Cancel
            </button>
          </div>
        </>
      ) : (
        <>
          <h4 className="text-lg font-semibold text-white mb-2">{note.title}</h4>
          <p className="text-gray-300 mb-4 whitespace-pre-wrap">{note.content}</p>
          <button
            onClick={() => deleteNote(note.id)}
            className="w-full bg-red-600 hover:bg-red-700 text-white py-2 px-4 rounded transition-colors"
          >
            Delete Planet
          </button>
        </>
      )}
    </div>
  </div>
);
```

};

return (
<div className="w-full h-screen bg-gradient-to-b from-gray-900 via-purple-900 to-gray-900 relative overflow-hidden">
{/* Stars background */}
<div className="absolute inset-0 opacity-60">
{[…Array(100)].map((_, i) => (
<div
key={i}
className=“absolute bg-white rounded-full animate-pulse”
style={{
left: `${Math.random() * 100}%`,
top: `${Math.random() * 100}%`,
width: `${Math.random() * 3 + 1}px`,
height: `${Math.random() * 3 + 1}px`,
animationDelay: `${Math.random() * 3}s`,
animationDuration: `${Math.random() * 2 + 2}s`
}}
/>
))}
</div>

```
  {/* Main canvas */}
  <div
    ref={canvasRef}
    className="w-full h-full relative select-none"
    style={{ 
      cursor: isDragging ? 'grabbing' : isCreating || selectedNote || editingNote ? 'default' : 'grab',
      touchAction: 'none'
    }}
    onClick={handleCanvasClick}
  >
    {/* Universe container with zoom and pan */}
    <div
      className="absolute inset-0 origin-top-left transition-transform duration-100"
      style={{
        transform: `translate(${pan.x}px, ${pan.y}px) scale(${zoom})`,
        width: '100%',
        height: '100%',
      }}
    >
    {/* Notes as planets */}
    {notes.map((note) => (
      <div
        key={note.id}
        className="absolute cursor-pointer transform -translate-x-1/2 -translate-y-1/2 hover:scale-110 transition-transform duration-200 group"
        style={{
          left: note.x,
          top: note.y,
          width: note.size,
          height: note.size,
        }}
        onClick={(e) => {
          e.stopPropagation();
          setSelectedNote(note);
        }}
      >
        <div
          className="w-full h-full rounded-full border-2 border-white border-opacity-30 relative overflow-hidden shadow-lg"
          style={{
            background: note.image ? 'none' : note.color,
            backgroundImage: note.image ? `url(${note.image})` : 'none',
            backgroundSize: 'cover',
            backgroundPosition: 'center',
          }}
        >
          {/* Planet glow effect */}
          <div className="absolute inset-0 rounded-full bg-gradient-to-br from-white from-0% via-transparent via-30% to-transparent opacity-20"></div>
          
          {/* Planet rings (sometimes) */}
          {Math.random() > 0.7 && (
            <div 
              className="absolute border border-white border-opacity-20 rounded-full"
              style={{
                width: note.size * 1.5,
                height: note.size * 0.3,
                left: '50%',
                top: '50%',
                transform: 'translate(-50%, -50%) rotateX(75deg)',
              }}
            />
          )}
        </div>
        
        {/* Planet label */}
        <div className="absolute -bottom-8 left-1/2 transform -translate-x-1/2 opacity-0 group-hover:opacity-100 transition-opacity duration-200">
          <div className="bg-black bg-opacity-70 text-white text-xs px-2 py-1 rounded whitespace-nowrap">
            {note.title}
          </div>
        </div>
      </div>
    ))}

    {/* Instructions */}
    {notes.length === 0 && (
      <div className="absolute inset-0 flex items-center justify-center">
        <div className="text-center text-white text-opacity-60">
          <Plus size={48} className="mx-auto mb-4 text-white text-opacity-40" />
          <p className="text-xl mb-2">Your Mind Universe Awaits</p>
          <p className="text-sm">Click anywhere in space to create your first note planet</p>
          <p className="text-xs mt-2">Drag to pan • Scroll or pinch to zoom</p>
        </div>
      </div>
    )}
    </div>
  </div>

  {/* Zoom indicator */}
  <div className="absolute top-4 right-4 bg-black bg-opacity-50 text-white px-3 py-1 rounded-full text-sm">
    {Math.round(zoom * 100)}%
  </div>

  {/* Modals */}
  {isCreating && <CreateNoteModal />}
  
  {selectedNote && (
    <NoteModal
      note={selectedNote}
      onClose={() => setSelectedNote(null)}
      isEditing={editingNote === selectedNote?.id}
      setIsEditing={(editing) => setEditingNote(editing ? selectedNote.id : null)}
    />
  )}
</div>
```

);
};

export default MindNotesUniverse;
